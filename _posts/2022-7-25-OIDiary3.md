---
layout: post
title: OI Diary 03：近期题解或笔记(数据结构初步)
categories: OI
description: Problem
keywords: NOIP, OI
---
[toc]

# 算法

## 扫描线

将数组$A=\{0\}$上进行 $N$ 次操作$(l,r,s_i)$。第$i$次操作将区间$[l,r]$上的每一个值加上$s_i$，求 $N$ 次操作后数组所有数中的最大值。

可以采用**扫描线**的方法：

首先标记数组：只需将$A[l]$加上$s_i$，将$A[r+1]$减去$s_i$。然后扫描数组时，在每一位上计算出的前缀和就是操作后这一位的实际值。

例如，对$A=\{0,0,0,0,0,0\}$进行操作$(0,3,2)$，先把数组标记成$A=\{2,0,0,0,-2,0\}$，扫描时计算前缀和：$\{2,2,2,2,0,0\}$。

**参考代码**

```cpp
#include <bits/stdc++.h>
using namespace std;

int A[1005];

int main(){
	int N,l,r,s,max_n=0;
	cin >> N;
	for(int i=1;i<=N;i++){
		cin >> l >> r >> s;
		A[l]+=s;
		A[r+1]-=s;
	} //标记 
	for(int i=1;i<=1005;i++){
		A[i]+=A[i-1];
		max_n=max(max_n,A[i]);
	}//扫描，加前缀和 
	cout << max_n;
	return 0;
}
```

时间复杂度：$O(n)$

## 离散化

对于某些只关心数之间大小关系，不关心数的具体值的题目，可以使用离散化的手法，缩小数据范围，简化算法。

例如对于$\{9,100,88,91,43,101\}$经过离散化变为$\{1,5,3,4,2,6\}$。

**参考代码**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX_N=100005;
struct arr{
	int old, rank, id;//old：原值, rank：离散化的排名，id：原顺序 
} a[MAX_N];
bool cmp1(arr a,arr b){
	return a.old<b.old;
}
bool cmp2(arr a,arr b){
	return a.id<b.id;
}

int main(){
	int n;
	cin >> n;
	for(int i=1;i<=n;i++){
		cin >> a[i].old;
		a[i].id=i;
	}//读入数据 
	sort(a+1,a+n+1,cmp1); //按old从小到大排序
	for(int i=1;i<=n;i++)	a[i].rank=i;//赋上rank
	sort(a+1,a+n+1,cmp2);//用id排回原来的顺序 
    for(int i=1;i<=n;i++)	cout<< a[i].rank << " ";//rank则为离散化的结果
	return 0;
}
```

# 数据结构

## 链表

数组的点查复杂度为$O(1)$，插入或删除复杂度为$O(n)$。

链表的点查复杂度为$O(n)$，插入或删除复杂度为$O(1)$。

除了储存数据以外，单项链表还储存$next$，双向链表储存$pre$和$next$。

**用结构体定义链表**

```cpp
struct node{
	int data, next;
};
int head;//头节点
```

找到头节点的方法：遍历链表时，标记其中被指向过的下标。没有被指向过的下标即为头节点的下标。

**链表的遍历**

```cpp
for(int i=head;;i=a[i].next){
	cout << a[i].data;
    if(!a[i].next)	break;//前提：a[i].next未被赋值时被初始化为0
}
```

链表的插入和删除只需将有关的$next$进行修改即可；链表的点查需要在遍历的基础上加以判断。

数组与链表的使用是*辩证* 的。

## vector

可以将$vector$当成不定长数组来使用。

**常用函数**

```cpp
vector <int> c		 //定义
c.clear()            //移除容器中所有数据
c.empty()            //判断容器是否为空 
c.erase(pos)         //删除pos位置的数据
c.erase(beg,end)     //删除[beg,end)区间的数据
c.front()            //传回第一个数据。
c.insert(pos,elem)   //在pos位置插入一个elem
c.pop_back()         //删除最后一个数据。
c.push_back(elem)    //在尾部加入一个数据。
c.resize(num)        //重新设置该容器的大小
c.size()             //返回容器中实际数据的个数。
c.begin()            //返回指向容器第一个元素的迭代器
c.end()              //返回指向容器最后一个元素的迭代器
```

注意到，`pos`需要传入一个迭代器。所以如果要抹去下标为 `i`的元素，需要使用 `c.erase(c.begin()+i);`。

遍历时，使用 `for(int i=0; i<c.size(); i++)`。

**二维vector**

```cpp
vector <vector <int>> c(3);
vector <int> c[3];
//这两种写法都使得(vector)c中能储存3个vector
```

**vector排序**

```cpp
vector <int> c;
sort(c.begin(), c.end(), cmp);//也可以不传cmp，默认从小到大排序
```

### (vector习题)小明的数字表

##### 输入格式

第一行输入一个 n (n<=100000)，表示数列的长度； 第二行 n 个正整数 ai (0<=ai<=100000000)； 第三行一个数字 q (q<=100000)表示询问的次数； 下面 q 行，每行给出三个数字 u,v,w, 表示查找第 u 位为数字 v 的所有数字中，第 w 小的数。

##### 输出格式

每个询问输出一个数字，查询不到输出“-1”。

##### 输入样例

```
4
1 21 22 3
3
2 2 2
1 1 2
2 2 3
```

##### 输出样例

```
22
21
-1
```

##### 参考程序(空间换时间)

```cpp
#include <bits/stdc++.h>
using namespace std;
vector <int> arr[10][10];//arr中可以储存10*10个vector

int main() { 
	int n,num,tnum,q,u,v,w,t=1;
	cin >> n;
	for(int i=0;i<n;i++){
		t=1;//第t位数
		cin >> num;
		tnum = num;
		while(tnum){
			arr[t][tnum%10].push_back(num);//arr[u][v]中储存了所有第u位为数字v的数
			tnum/=10;t++;
		}
	}
	for(int i=0;i<10;i++){
		for(int j=0;j<10;j++){
			sort(arr[i][j].begin(),arr[i][j].end());//对所有的arr[u][v]从小到大排序
		}
	}
	cin >> q;
	for(int i=0;i<q;i++){
		cin >> u >> v >> w;
		if(arr[u][v].size()>=w)	cout << arr[u][v][w-1] << endl;//如果存在第w小的数就输出
		else	cout << -1 << endl;
	}
	return 0;
}
```

## 栈

栈是后进先出的数据结构。

可以用数组实现一个栈：

```cpp
int t[10001];
int head=0;//元素个数（栈顶下标）
int size(){
	return head;
}//获得栈的大小
int top(){
	return t[head-1];
}//获得栈顶元素
void push(int x){
	t[head++]=x;
}
void pop(){
	head--;
}
```

也可以使用 `C++`的 `stack`模板：

```cpp
#include <stack>
stack <int> t;
```

它具备上方实现的四个功能，而且有一个 `t.empty()`函数，返回栈是否为空。

利用栈的思想，容易解决合法括号匹配等问题。这些问题表面上不一定与栈直接有关。

## 队列

队列是先进先出的数据结构。

可以用数组实现一个队列：

```cpp
int q[100001];
int head=1;
int tail=0;
void push(int x){
	q[++tail]=x;
}
void pop(){
	head++;
}
int size(){
	return tail-head+1;
}
int front(){
	return q[head];
}
```

也可以使用 `C++`的 `queue`模板：

```cpp
#include <queue>
queue <int> q;
```

它具备上方实现的四个功能，并有以下函数：

```cpp
q.back();	//返回队尾元素
q.empty();	//返回队列是否为空
```

队列的基本用途是模拟有关排队、抽牌等问题。

# 题解

## [NOIP2001 普及组] 数的计算

### 题目描述

我们要求找出具有下列性质数的个数（包含输入的正整数 $n$）。

先输入一个正整数 $n$（$n \le 1000$），然后对此正整数按照如下方法进行处理：

1. 不作任何处理；
2. 在它的左边拼接一个正整数，但该正整数不能超过原数，或者是上一个被拼接的数的一半；
3. 加上数后，继续按此规则进行处理，直到不能再加正整数为止。

### 输入格式

一行，一个正整数 $n$（$n \le 1000$）。

### 输出格式

一个整数，表示具有该性质数的个数。

### 样例 #1

#### 样例输入 #1

```
6
```

#### 样例输出 #1

```
6
```

### 提示

**【样例解释】**

满足条件的数为：$6$，$16$，$26$，$126$，$36$，$136$。

**【题目来源】**

NOIP 2001 普及组第一题

### 代码

#### 递归（记忆化搜索）

暴力搜索的思路为：当调用 `f(n)`时，枚举 `1~(n/2)` 中的数(`i`)，然后再调用 `f(i)`，直到 `f(1)`直接返回。每一次调用都让计数器 `t++`（因为每调用一次函数就意味着有一个合法答案）。

但是如果不记忆化的话，上述思路会TLE(因为 `f(999)=1955133450`，意味着要调用1955133450次函数)。不过实际考试中可以考虑打表。

更好的选择是写成记忆化，也就是以下代码：

```c++
#include <bits/stdc++.h>
using namespace std;

int t,memory[1001],i;

int f(int n){
    t=1;//这个数本身就算一个答案
    for(i=1;i<=n/2;i++){
        if(!memory[i])  memory[i]=f(i);
        t+=memory[i];
    }
    return t;
}

int main(){
    int n;
    cin >> n;
    cout << f(n);
    return 0;
}
```

添加了 `memory`数组进行记忆。注意到，若写记忆化算法，函数需要有返回值，而不采用暴力计数器。这其实算是比较典型的递归算法。

写成递归公式为：

$$
f(n)=\begin{cases}
\sum\limits_{i=1}^{n/2}f(i) & (n>1)\\
1 & (n=1)
\end{cases}
$$

#### 递推

其实这题的最好写法是递推。

可以推出，递推公式为：

$$
f[1]=1\\
f[n]=1+\sum\limits_{i=1}^{n/2}f[i]
$$

这样一来，代码就好写多了。

```c++
#include <bits/stdc++.h>
using namespace std;

int f[1001];

int main(){
    f[1]=1;
    int n;
    cin >> n;
    for(int i=2;i<=n;i++){
        for(int j=1;j<=i/2;j++){
            f[i]+=f[j];
        }
        f[i]++;
    }
    cout << f[n];
    return 0;
}
```

> 题目描述复制自洛谷。
