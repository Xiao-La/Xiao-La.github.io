---
layout: post
title: 暑期笔记 | 近期杂类笔记 (位运算和高精等)
categories: OI
description: Note
keywords: NOIP, OI, Note
---

- [位运算](#位运算)
	- [基本概念](#基本概念)
	- [常用技巧](#常用技巧)
	- [习题1](#习题1)
	- [习题2](#习题2)
	- [习题3](#习题3)
- [高精度基础](#高精度基础)
	- [模板（无压位）](#模板无压位)

## 位运算

运用位运算，能简化一些问题。

### 基本概念

1. `&` **按位与**	同为1则得出1，否则为0
2. `|`**按位或**	同为0则得出0，否则为1
3. `^` **按位异或**	相同为0，不同为1，相当于不进位加法
   - `^`优先级高于 `|`和 `&`
   - `a ^ a = 0,  a ^ 0 = a`
   - `x ^ y = (x | y) - (x & y)`
4. `~` 取反
5. `<<` 左移	$x << k = x \times 2^{k}$
6. `>>` 右移	$x >> k = \lfloor x\div 2^k\rfloor$

十进制的位运算都要先转换成二进制，再按位进行。每一位的规则与逻辑运算类似。

$e.g.$

 $5 \& 6=(101)_2\&(110)_2=(100)_2=4$

$7 \& 13=(111)_2\&(1101)_2=(101)_2=5$

### 常用技巧

1. `lowbit = (x&(-x))`	$lowbit(x)$获得一个数二进制的最后一个为 $1$ 的 $bit$
2. `n&(n-1)==0` 判断一个数是否为$2$的幂
3. `n&((1<<x)-1)`求$n \mod 2^x$
4. `(x^y)>=0`判断两个数符号是否相同

例如，可以用来统计一个数的二进制形式中$1$的个数：

```cpp
int cntBit(int x){
	int ret = 0;
	while(x){
		ret++;
		x -= x&(-x);// x&(-x)即lowbit
        // x &= x-1	也可以代替上一句求出lowbit
	}
	return ret;
} 
```

生成n位格雷码：

```cpp
int n;
for(int i=0;i<(1 << n);i++){
	int code = (i >> 1) ^ i;
    print_2(code, n); //假设print_2可以输出n位二进制形式
}
```

### 习题1

输入一个长度为$n$的数组，考虑所有不同的数字，有且只有一个数字出现了奇数次。

输出这个出现了奇数次的数字。

**代码**

```cpp
int n, num, ans=0;
cin >> n;
for(int i=1;i<=n;i++){
	cin >> num;
	ans ^= num;
}
cout << ans;// 出现偶数次的数一定会被异或变成0，留下的就是要求的数字
```

### 习题2

给出区间$[a,b]$，求$a\ xor\ (a+1)\ xor\ (a+2) ..... \ xor\ b$。

**题解**

设$f(x)$为从$1$到$x$的**前缀异或**。那么原式等于$[f(b)\ xor f(a-1)]$。

对于任意的$f(x)$，考虑到$0\ xor\ 1=1;\ 2\ xor\ 3=1;\ 4\ xor\ 5=1...$

所以有：$f(x)=\begin{cases}
1 & (x\mod 4=1)\\
0 & (x\mod 4=3)\\
f(x-1)\ xor\ x & (其他情况) \end{cases}$。

直接写成代码即可。

### 习题3

给出两个数$a$，$b$。问$a$能否只通过位移运算（ `>>`和 `<<` 可以多次使用）变成$b$。

**题解**

如果可以变成$b$，那么可以说$b$的二进制删除了前导和后缀$0$后，是$a$的子串。

```cpp
#include <iostream>
using namespace std;

int main(){
	int t, a, b;
	cin >> t;
	for(int i=1; i<=t; i++){
		bool flag = 0;
		cin >> a >> b;
		while(b%2==0 && b)	b /= 2; // 去除b尾部的所有0 
		while(a>0){
			if((a&b)==b){ //a&b运算后为b本身，可知b的所有1的位置 a都是1，其他不确定 
				int t = a ^ b;
				int lowbit = t & (-t);
				if(t==0 || lowbit>b)	flag = 1;
                //t==0 : 完全一样则异或为0；lowbit>b ： 异或后的1的位置大于b的
                //同时满足即可
			}
			a >>= 1;
		}
		if(flag)	cout<<"Yes"<<endl;
		else	cout<<"No"<<endl;
	}
	return 0;
}
```

## 高精度基础

高精度这块就是模拟。其中压位的思想可以省一些时空，但是其实大部分题不压位也能过，所以直接拿十进制模板写就够了。

### 模板（无压位）

以下给出高精度加减的模板。

这些函数都有一些局限，所以如果不知道给出的两个数的正负，需要先判断：两个数同正负，可处理成高精加；两个数一正一负，可处理成高精减。

```cpp
int ta[10001], tb[10001];
// add 假定a与b同正负,返回a+b
string add(string a, string b){
    memset(ta,0,sizeof(ta));
	memset(tb,0,sizeof(tb));
	string ans;
	bool flag = 0;//是否需要加负号
	if(a[0]=='-'&&b[0]=='-'){
		flag = 1;
		a.erase(a.begin());
		b.erase(b.begin());
	}//a,b同负时，抹负号，最后加负号
	int len_a = a.length(), len_b = b.length();
	int len = max(len_a, len_b);
	for(int i=1; i<=a.length(); i++)	ta[i] = a[len_a-i]-'0';
	for(int i=1; i<=b.length(); i++)	tb[i] = b[len_b-i]-'0';
	int cnt=0;
	for(int i=1; i<=len; i++){
		cnt += ta[i] + tb[i];
		ans = char(cnt%10 + '0') + ans;
		cnt /= 10;
	}
	if(cnt)		ans = "1" + ans;
	if(flag)	ans = "-" + ans;
	return ans;
}

//sub 假定a与b同正，返回a-b
string sub(string a, string b){
    memset(ta,0,sizeof(ta));
	memset(tb,0,sizeof(tb));
	string ans;
    bool flag = 0;//是否需要加负号
	int len_a = a.length(), len_b = b.length();
	if((len_a<len_b)||(len_a==len_b&&a[0]<b[0])){
		swap(a, b);
		flag = 1;
	}//a<b时交换，最后加负号
	int len = max(len_a, len_b);
	for(int i=1; i<=a.length(); i++)	ta[i] = a[len_a-i]-'0';
	for(int i=1; i<=b.length(); i++)	tb[i] = b[len_b-i]-'0';
	for(int i=1;i<=len;i++){
		int tmp = ta[i]-tb[i];
		if(tmp < 0){
			tmp+=10;
			ta[i+1]--;
		} 
		ans = char(tmp + '0') + ans;
	}
	while(ans[0]=='0')	ans.erase(ans.begin());
	if(flag)	ans = "-" + ans;
    return ans;
}
```

给出高精乘的模板：

```cpp
int ta[100001], tb[100001], ts[100001];
string mult(string a,string b){
	memset(ta,0,sizeof(ta));
	memset(tb,0,sizeof(tb));
	memset(ts,0,sizeof(ts));
	string ans;
	ta[0]=a.length();tb[0]=b.length();
	int len=ta[0]+tb[0];
	for(int i=1;i<=ta[0];i++)	ta[i]=a[ta[0]-i]-'0';
	for(int i=1;i<=tb[0];i++)	tb[i]=b[tb[0]-i]-'0';
	for(int i=1;i<=ta[0];i++)	for(int j=1;j<=tb[0];j++)	ts[i+j-1]+=ta[i]*tb[j];// 对于a的第i位乘b的第j位，它贡献在答案的 i+j-1 位
	for(int i=1;i<=ta[0]+tb[0];i++){
		if(ts[i]>9){
			ts[i+1]+=ts[i]/10;ts[i]%=10;//进位，每一位只留下个位
		}
	}
	while(ts[len]==0&&len>1)	len--;
	for(int i=1;i<=len;i++)	ans=char(ts[i]+'0')+ans;

	return ans;
}
```