---
layout: post
title: CSP 2022 第二轮 部分题解
categories: Solution
description: OI Diary
keywords: NOIP, OI, CSP, vp
---

这两天在家模拟考了 CSP。

总体来说， J 组 T1T2 都是纯纯送分， T3 大模拟有点难调（到现在还没调出来），T4 是不太难的 dp。

S 组 T1 有很多暴力分， T2 思维难度小但是码量大，导致 T3T4 都没时间写暴力。

- [CSP-J T1 pow](#csp-j-t1-pow)
  - [题解](#题解)
- [CSP-J T2 decode](#csp-j-t2-decode)
  - [题解](#题解-1)
- [CSP-J T4 point](#csp-j-t4-point)
  - [题解](#题解-2)
- [CSP-S T2 game](#csp-s-t2-game)
  - [题解](#题解-3)

## CSP-J T1 pow

请你计算 $a^b$。当它的值超过 ${10}^9$ 时，输出一个 `-1` 进行警示，否则就输出正确的 $a^b$ 的值。

$1 \le a, b \le 10^9$

### 题解

时间复杂度 $O(\log_a 10^9)$。特判一下 $a=1$ 的情况即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mx = 1e9;
inline ll read() {...}
inline void write(ll x) {...}

int main() {
    ll a = read(), b = read(), ret = 1;
    if(a == 1) {write(1); return 0;}
    for(int i = 1; i <= b; i++) {
        ret *= a;
        if(ret > mx) {write(-1); return 0;}
    }
    write(ret);
    return 0;
}
```
## CSP-J T2 decode


给定一个正整数 $k$，有 $k$ 次询问，每次给定三个正整数 $n_i, e_i, d_i$，求两个正整数 $p_i, q_i$，使 $n_i = p_i \times q_i$、$e_i \times d_i = (p_i - 1)(q_i - 1) + 1$。如果无解，输出 `NO`。

$1 \leq k \leq {10}^5$；

对于任意的 $1 \leq i \leq k$，$1 \leq n_i \leq {10}^{18}$，$1 \leq e_i \times d_i \leq {10}^{18}$
，$1 \leq n - e \times d + 2 \leq {10}^9$。

### 题解

注意到 $\cases {p\times q=n=\text{constant}\\ p+q=n-e\times d + 2 = \text{constant}}$

于是用韦达定理逆定理构造方程，则 $p, q$ 为方程 $x^2 -(n-e\times d + 2)x + n = 0$ 的两实根，暴力用求根公式即可。注意判一下是否是整数解。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

inline ll read() {...}
inline void write(ll x) {...}

int main() {
    int k = read();
    while(k--) {
        ll n = read(), e = read(), d = read();
        ll sum = n - e * d + 2;
        ll delta = sum * sum - 4 * n;
        ll s = sqrt(delta);
        if(s * s != delta || ((sum - s) & 1) || ((sum + s) & 1)) {
            printf("NO\n");
        }
        else {
            ll p = (sum - s) >> 1, q = (sum + s) >> 1;
            write(p), putchar(' '), write(q);
            putchar('\n');
        }
    }
    return 0;
}
```

## CSP-J T4 point

给定平面直角坐标系中的 $n$ 个整数点 $(x_i, y_i)$，此外你还可以自由添加 $k$ 个整数点。在自由添加 $k$ 个点后，从 $n + k$ 个点中选出若干个整数点并组成一个序列。

合法的序列满足任意相邻两点之间有 $x_{i+1} - x_i = 1, y_{i+1} = y_i$ 或 $y_{i+1} - y_i = 1, x_{i+1} = x_i$。求合法序列的最大长度。

$1\le n \le 500, 0 \le k \le 100$

### 题解

用 $dp_{i,m}$ 表示考虑前 $i$ 个点，已经添加 $m$ 个点的最长上升点列的长度。那么转移方程如下：

$$
dp_{i,m} = \max\limits_{1\le j < i}^{f(j, i) \le k}(dp_{i, m}, dp_{j, m-f(j,i)}+f(j,i)+1)
$$

其中 $f(j, i)$ 表示点 $A_j$ 到 $A_i$ 能够接上最少要用几个额外点。

答案相比于 dp 的状态， 还需要加上剩下的点数 $(k - m)$，因为一定可以把剩下的点加到点列中。

那么 `sort` 一遍，暴力 dp 即可。时间复杂度： $O(n^2k)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int MAX_N = 510;
pii a[MAX_N];
ll dp[MAX_N][MAX_N], ans, n, k;
inline ll read() {...}
inline void write(ll x) {...}

inline bool cmp(pii A, pii B) {return A.first == B.first ? A.second < B.second : A.first < B.first;}
inline ll dis(pii A, pii B) {return B.second - A.second + B.first - A.first;}
int main() {
    n = read(), k = read();
    for(int i = 1; i <= n; i++) a[i].first = read(), a[i].second = read();       
    sort(a + 1, a + n + 1);
    for(int i = 1; i <= n; i++) {
        dp[i][0] = 1;
        for(int j = 1; j < i; j++) {
            ll q = dis(a[j], a[i]) - 1;
            if(a[i].first < a[j].first || a[i].second < a[j].second)    continue;
            for(int m = q; m <= k; m++) {
                dp[i][m] = max(dp[i][m], dp[j][m - q] + q + 1);                  
                ans = max(ans, dp[i][m] + k - m);
            }
        }
    }
    write(ans);
    return 0;
}
```

## CSP-S T2 game

小 L 和小 Q 在玩一个策略游戏。

有一个长度为 $n$ 的数组 $A$ 和一个长度为 $m$ 的数组 $B$，在此基础上定义一个大小为 $n \times m$ 的矩阵 $C$，满足 $C_{i j} = A_i \times B_j$。所有下标均从 $1$ 开始。

游戏一共会进行 $q$ 轮，在每一轮游戏中，会事先给出 $4$ 个参数 $l_1, r_1, l_2, r_2$，满足 $1 \le l_1 \le r_1 \le n$、$1 \le l_2 \le r_2 \le m$。

游戏中，小 L 先选择一个 $l_1 \sim r_1$ 之间的下标 $x$，然后小 Q 选择一个 $l_2 \sim r_2$ 之间的下标 $y$。定义这一轮游戏中二人的得分是 $C_{x y}$。

小 L 的目标是使得这个得分尽可能大，小 Q 的目标是使得这个得分尽可能小。同时两人都是足够聪明的玩家，每次都会采用最优的策略。

请问：按照二人的最优策略，每轮游戏的得分分别是多少？

$1 \le n, m, q \le {10}^5$，$-{10}^9 \le A_i, B_i \le {10}^9$，$1 \le l_1 \le r_1 \le n$，$1 \le l_2 \le r_2 \le m$。


### 题解

考虑到小 L 的决策首先取决于 小 Q 能选的数中是 **全正** 还是 **全负** 还是 **有正有负**。

我们 **取其中一种情况** 来具体分析：

如果小 Q 能选的数全正，那么小 L 为了使得分尽量大，会作出这样的决策：手里有正数就会选最大的正数(决策 $1$)，手里没有正数就会选最大的负数(决策 $2$)。

对于决策 $1$，小 Q 的回应必然是选他手里 **最小的正数**。对于决策 $2$，小 Q 的回应必然是选他手里 **最大的正数**。

对于其他情况，同样分两类即可。特别的，一正一负的分类有可能两种决策都可能发生，那么需要取两种决策中的最大值。

可以选择线段树或 ST 表维护区间最值。线段树代码长但好调试，ST 表代码短但难调试。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAX_N = 1e5 + 10, MAX_LOG = 19, INF = 1e9 + 10;
int log_2[MAX_N];

void init_log() {
    log_2[1] = 0, log_2[2] = 1;
    for(int i = 3; i < MAX_N; i++) log_2[i] = log_2[i >> 1] + 1;
}

struct st {
    int minn[MAX_N][MAX_LOG], maxn[MAX_N][MAX_LOG], len;
    void init() {
        for(int j = 1; j <= MAX_LOG; j++) {
            for(int i = 1; i + (1 << (j - 1)) - 1 <= len; i++) {
                minn[i][j] = INF, maxn[i][j] = -INF;
                minn[i][j] = min(minn[i][j - 1], minn[i + (1 << (j - 1))][j - 1]);
                maxn[i][j] = max(maxn[i][j - 1], maxn[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
    int query(int l, int r, int type) {
        int t = log_2[r - l + 1];
        if(type == 1) return min(minn[l][t], minn[r - (1 << t) + 1][t]);
        else    return max(maxn[l][t], maxn[r - (1 << t) + 1][t]);
    } 
} st1, st1_m, st2;

inline ll read() {...}
inline void write(ll x) {...}

int main() {
    int n = read(), m = read(), q = read();
    init_log();
    for(int i = 1; i <= n; i++) {
        int x = read();
        if(x >= 0) {
            st1.maxn[i][0] = st1.minn[i][0] = x;
            st1_m.maxn[i][0] = -INF;
            st1_m.minn[i][0] = INF;
        }
        else {
            st1_m.maxn[i][0] = st1_m.minn[i][0] = -x;
            st1.maxn[i][0] = -INF;
            st1.minn[i][0] = INF;
        }
    }
    for(int i = 1; i <= m; i++) {
        int x = read();
        st2.maxn[i][0] = st2.minn[i][0] = x;
    }
    st2.len = m; st1.len = st1_m.len = n;
    st1.init(), st2.init(), st1_m.init();
    while(q--) {
        ll ans = 0;
        int l1 = read(), r1 = read(), l2 = read(), r2 = read();
        if(st2.query(l2, r2, 1) < 0 && st2.query(l2, r2, 2) >= 0) {
            if(st1.query(l1, r1, 2) == -INF)    ans = 1ll * (-1) * st1_m.query(l1, r1, 1) * st2.query(l2, r2, 2);
            else if(st1_m.query(l1, r1, 2) == -INF)    ans = 1ll * st1.query(l1, r1, 1) * st2.query(l2, r2, 1);
            else ans = max(1ll * (-1) * st1_m.query(l1, r1, 1) * st2.query(l2, r2, 2),  1ll * st1.query(l1, r1, 1) * st2.query(l2, r2, 1));
        }
        else if(st2.query(l2, r2, 1) < 0 && st2.query(l2, r2, 2) < 0) {
            if(st1_m.query(l1, r1, 2) == -INF) ans = 1ll * st1.query(l1, r1, 1) * st2.query(l2, r2, 1);
            else ans = 1ll * (-1) * st1_m.query(l1, r1, 2) * st2.query(l2, r2, 2);
        }
        else {
            if(st1.query(l1, r1, 2) == -INF) ans = 1ll * (-1) * st1_m.query(l1, r1, 1) * st2.query(l2, r2, 2);
            else    ans = 1ll * st1.query(l1, r1, 2) * st2.query(l2, r2, 1);
        }
        write(ans); putchar('\n');
    }
    return 0;
}
```