---
layout: post
title: 暑期笔记 | 刷题题解
categories: OI
description: Note
keywords: NOIP, OI, Note
---
有学习新知识中的水题，也有需要思考的好题。暑假的题将会堆这里。

- [区间加和问题](#区间加和问题)
- [[NOIP2001 普及组] 数的计算](#noip2001-普及组-数的计算)
	- [题目描述](#题目描述)
	- [输入格式](#输入格式)
	- [输出格式](#输出格式)
	- [样例 #1](#样例-1)
		- [样例输入 #1](#样例输入-1)
		- [样例输出 #1](#样例输出-1)
	- [提示](#提示)
	- [题解](#题解)
		- [递归（记忆化搜索）](#递归记忆化搜索)
		- [递推](#递推)
- [[NOIP1998 普及组] 幂次方](#noip1998-普及组-幂次方)
	- [题目描述](#题目描述-1)
	- [输入格式](#输入格式-1)
	- [输出格式](#输出格式-1)
	- [样例 #1](#样例-1-1)
		- [样例输入 #1](#样例输入-1-1)
		- [样例输出 #1](#样例输出-1-1)
	- [提示](#提示-1)
	- [题解](#题解-1)
- [确定进制(进制，暴力枚举)](#确定进制进制暴力枚举)
	- [输入格式](#输入格式-2)
	- [输出格式](#输出格式-2)
	- [输入样例](#输入样例)
	- [输出样例](#输出样例)
	- [题解](#题解-2)
- [花钱买车牌(贪心)](#花钱买车牌贪心)
	- [输入格式](#输入格式-3)
	- [输出格式](#输出格式-3)
	- [输入样例](#输入样例-1)
	- [输出样例](#输出样例-1)
	- [样例解释](#样例解释)
	- [题解](#题解-3)
- [连续整数的和(数学，枚举的优化)](#连续整数的和数学枚举的优化)
	- [输入格式](#输入格式-4)
	- [输出格式](#输出格式-4)
	- [输入样例](#输入样例-2)
	- [输出样例](#输出样例-2)
	- [题解](#题解-4)
- [小b学进制(数学，进制，枚举的优化)](#小b学进制数学进制枚举的优化)
	- [输入格式](#输入格式-5)
	- [输出格式](#输出格式-5)
	- [输入样例](#输入样例-3)
	- [输出样例](#输出样例-3)
	- [题解](#题解-5)

## 区间加和问题

将数组$A=\{0\}$上进行 $N$ 次操作$(l,r,s_i)$。第$i$次操作将区间$[l,r]$上的每一个值加上$s_i$，求 $N$ 次操作后数组所有数中的最大值。

可以采用**扫描线**的方法：

首先标记数组：只需将$A[l]$加上$s_i$，将$A[r+1]$减去$s_i$。然后扫描数组时，在每一位上计算出的前缀和就是操作后这一位的实际值。

例如，对$A=\{0,0,0,0,0,0\}$进行操作$(0,3,2)$，先把数组标记成$A=\{2,0,0,0,-2,0\}$，扫描时计算前缀和：$\{2,2,2,2,0,0\}$。

**参考代码**

```cpp
#include <bits/stdc++.h>
using namespace std;

int A[1005];

int main(){
	int N,l,r,s,max_n=0;
	cin >> N;
	for(int i=1;i<=N;i++){
		cin >> l >> r >> s;
		A[l]+=s;
		A[r+1]-=s;
	} //标记 
	for(int i=1;i<=1005;i++){
		A[i]+=A[i-1];
		max_n=max(max_n,A[i]);
	}//扫描，加前缀和 
	cout << max_n;
	return 0;
}
```

时间复杂度：$O(n)$

## [NOIP2001 普及组] 数的计算

[洛谷 P1028](https://www.luogu.com.cn/problem/P1028)

### 题目描述

我们要求找出具有下列性质数的个数（包含输入的正整数 $n$）。

先输入一个正整数 $n$（$n \le 1000$），然后对此正整数按照如下方法进行处理：

1. 不作任何处理；
2. 在它的左边拼接一个正整数，但该正整数不能超过原数，或者是上一个被拼接的数的一半；
3. 加上数后，继续按此规则进行处理，直到不能再加正整数为止。

### 输入格式

一行，一个正整数 $n$（$n \le 1000$）。

### 输出格式

一个整数，表示具有该性质数的个数。

### 样例 #1

#### 样例输入 #1

```
6
```

#### 样例输出 #1

```
6
```

### 提示

**【样例解释】**

满足条件的数为：$6$，$16$，$26$，$126$，$36$，$136$。

**【题目来源】**

NOIP 2001 普及组第一题

### 题解

#### 递归（记忆化搜索）

暴力搜索的思路为：当调用 `f(n)`时，枚举 `1~(n/2)` 中的数(`i`)，然后再调用 `f(i)`，直到 `f(1)`直接返回。每一次调用都让计数器 `t++`（因为每调用一次函数就意味着有一个合法答案）。

但是如果不记忆化的话，上述思路会TLE(因为 `f(999)=1955133450`，意味着要调用1955133450次函数)。不过实际考试中可以考虑打表。

更好的选择是写成记忆化，也就是以下代码：

```c++
#include <bits/stdc++.h>
using namespace std;

int t,memory[1001],i;

int f(int n){
    t=1;//这个数本身就算一个答案
    for(i=1;i<=n/2;i++){
        if(!memory[i])  memory[i]=f(i);
        t+=memory[i];
    }
    return t;
}

int main(){
    int n;
    cin >> n;
    cout << f(n);
    return 0;
}
```

添加了 `memory`数组进行记忆。注意到，若写记忆化算法，函数需要有返回值，而不采用暴力计数器。这其实算是比较典型的递归算法。

写成递归公式为：

$$
f(n)=\begin{cases}
\sum\limits_{i=1}^{n/2}f(i) & (n>1)\\
1 & (n=1)
\end{cases}
$$

#### 递推

其实这题的最好写法是递推。

可以推出，递推公式为：

$$
f[1]=1\\
f[n]=1+\sum\limits_{i=1}^{n/2}f[i]
$$

这样一来，代码就好写多了。

```c++
#include <bits/stdc++.h>
using namespace std;

int f[1001];

int main(){
    f[1]=1;
    int n;
    cin >> n;
    for(int i=2;i<=n;i++){
        for(int j=1;j<=i/2;j++){
            f[i]+=f[j];
        }
        f[i]++;
    }
    cout << f[n];
    return 0;
}
```

## [NOIP1998 普及组] 幂次方

[洛谷 P1010](https://www.luogu.com.cn/problem/P1010)

### 题目描述

任何一个正整数都可以用 $2$ 的幂次方表示。例如 $137=2^7+2^3+2^0 $。

同时约定方次用括号来表示，即 $a^b$ 可表示为 $a(b)$。

由此可知，$137$ 可表示为 $2(7)+2(3)+2(0)$

进一步：

$7= 2^2+2+2^0$  ( $2^1$ 用 $2$ 表示)，并且 $3=2+2^0$。

所以最后 $137$ 可表示为 $2(2(2)+2+2(0))+2(2+2(0))+2(0)$。

又如 $1315=2^{10} +2^8 +2^5 +2+1$

所以 $1315$ 最后可表示为 $2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)$。

### 输入格式

一行一个正整数 $n$。

### 输出格式

符合约定的 $n$ 的 $0, 2$ 表示（在表示中不能有空格）。

### 样例 #1

#### 样例输入 #1

```
1315
```

#### 样例输出 #1

```
2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)
```

### 提示

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^4$。

### 题解

这题一看就是个二进制题...正好这两天有学过这部分内容，其实挺水的也挺好理解的。所以直接看代码吧。

```cpp
#include <iostream>
#include <cstring>
using namespace std;

string get_cl(int x){
    string ans;
    int tmp = 0;
    while(x){
        //使用二进制， tmp 为当前计算的位数
        if(x%2 == 1){ // 当前的二进制位为 1 即 存在这个分解： 2^(tmp)
            string t = to_string(tmp);
            if(tmp != 0 && tmp != 1 && tmp != 2)    t = get_cl(tmp);//要继续分解的几种情况  
            if(tmp == 1)    ans = "+2" + ans;
            else    ans = "+2("+t+")" + ans;  //推入答案 
        }  
        tmp++;
        x /= 2;
    }
    ans.erase(ans.begin()); // 开头会有一个加号要抹去
    return ans;
}

int main(){
    int n;
    cin >> n;
    cout << get_cl(n);
	return 0;
}
```

## 确定进制(进制，暴力枚举)

[51nod P2646](http://class.51nod.com/Challenge/Problem.html#problemId=2646)

$6\times 9=42$对于$10$进制来说是错误的，但是对于$13$进制来说是正确的。

现在编写一段程序，读入三个整数$p$、$q$和$r$，然后确定一个进制$B$（$2\le B\le 16$）使得$p\times q=r$。如果$B$有很多选择，输出最小的一个。

### 输入格式

一行，包含三个整数p、q和r。p、q、r的 所有位都是数字，并且1 <= p、q、r <= 1000000

### 输出格式

一个整数B（使得p*q=r成立的最小B，如果没有合适的B输出0，且2<=B<=16）

### 输入样例

```
12 4 48
```

### 输出样例

```
9
```

### 题解

由于进制数$B$的范围较小，可以枚举所有进制，然后把这个$B$进制数转换成十进制来检验等式是否成立。知识点主要是复习怎么写转换成十进制的函数。

**参考代码**

```cpp
#include <iostream>
#include <cmath>
using namespace std;
int p, q, r;

int to_10(int a, int i){
	int cnt = 0, a_10 = 0;
	while(a){
		if(a%10 >= i)	return -1; // 如果这一位大等于进制数，那么显然不合法
		a_10 += (a%10)*pow(i, cnt);
		cnt++;	a /= 10;
	}
	return a_10;
}

bool check(int i){
	int a = p, b = q, c = r;
	int a_10 = to_10(a, i);
	int b_10 = to_10(b, i);
	int c_10 = to_10(c, i);
	if(a_10==-1||b_10==-1||c_10==-1)	return false;
	if(a_10*b_10==c_10)	return true;
	return	false;
}

int main(){
	cin >> p >> q >> r;
	for(int i=2; i<=16; i++){
		if(check(i)){
			cout << i;
			return 0;
		}
	} 
	cout << 0;
	return 0;
}
```

## 花钱买车牌(贪心)

[51nod P1621](http://class.51nod.com/Challenge/Problem.html#problemId=1621)

一个车牌号由n位数字组成。如果一个车牌至少有k位数字是相同的，那么我们就说这个车牌漂亮的车牌。现在华沙想要改变他自己的车牌，使得他的车牌变得漂亮。当然，改车牌是要花钱的。每改变一位数字所要花费的费用等于当前位上的新旧数字之差的绝对值。那么总费用就是每位上所花费用的总和。

华沙想用最少的钱，使他的车牌变得漂亮起来。现在给定n，k，和旧牌的号码，请你计算换牌的最少费，以及新牌的号码。如果最少费用的号码有多个，我们取**字典序最小**的那个。（2<=k<=n<=10^4）

### 输入格式

第一行输入两个数字n和k； 第二行输入n位数字，代表华沙的旧车牌。

### 输出格式

第一行输出一个整数，代表换牌的最小费用， 第二行输出n位数字，表示新的车牌。

### 输入样例

```
6 5
898196
```

### 输出样例

```
4
888188
```

### 样例解释

在样例中，把第二个数字换成“8”花费 abs(9-8) ＝1，把第五个数字换成“8”也花了1。

把第六个数字换成“8”花费abs(6-8)＝2.总费用为1+1+2＝4，新号码为“888188”

### 题解

考虑从 $0$ 到 $9$ 枚举每一个数作为目标的**相同的数**， 求出以它为**相同的数**时的**最少价格**与对应车牌，再取这$10$个答案中价格与字典序最小的答案。

以$i$为**相同的数**的**最少价格**的求法，需要一点**贪心**的思想，即：

先从前往后修改每一个找到的 $i + 1$ ，再从后往前修改每一个找到的$i-1$。这样的修改代价是$1$。

先从前往后修改每一个找到的 $i + 2$ ，再从后往前修改每一个找到的$i-2$。这样的修改代价是$2$。

$...$

先从前往后修改每一个找到的 $i + p$ ，再从后往前修改每一个找到的$i-p$。这样的修改代价是$p$。

（先后顺序是因为修改$i+p$使得字典序变小，修改$i-p$使得字典序变大）

在此过程中，每次修改使得相同的数的个数加$1$。如果使得相同的数达到了目标的个数，则退出循环，也就找到了最小的价格。

**参考代码**

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
int cp[11];

int main(){
	int n, k, cur_p, min_p = 1 << 30;
	string sign, ans;
	cin >> n >> k;
	cin >> sign;
	string sign_c = sign; // copy一份，枚举时重置sign 
	for(int i=0; i<n; i++)	cp[sign[i]-'0']++; //统计某个数字的个数 
	for(int i=0; i<=9; i++){
		// 从 0 到 9 枚举每一个数作为相同的数， 比较价格 
		sign = sign_c; cur_p = 0;  // cur_p : 当前价格 
		if(cp[i]>=k){	cout << cur_p << endl << sign;	return 0;}
		else{
			int cur_n = cp[i];  // 当前有几个数字i 
			int p = 1;
			while(cur_n<k){
				for(int m=0; m<n; m++){ // 从前往后查找 i + p 
					if(cur_n >= k)	break;
					if(sign[m]-'0' == i+p){
						sign[m] = char(i+'0');
						cur_n++;
						cur_p += p;
					}
				}
				for(int m=n-1; m>=0; m--){ // 从后往前查找 i - p 
					if(cur_n >= k)	break;
					if(sign[m]-'0' == i-p){
						sign[m] = char(i+'0');
						cur_n++;
						cur_p += p;
					}
				}
				p++;
			}
			if(cur_p < min_p){	ans = sign;	min_p = cur_p;}
			if(cur_p == min_p)	ans = min(ans, sign);
		}
	}
	cout << min_p << endl << ans;
	return 0;
}
```

## 连续整数的和(数学，枚举的优化)

[51nod P1138](http://class.51nod.com/Challenge/Problem.html#problemId=1138)

给出一个正整数N，将N写为若干个连续数字和的形式(长度 >= 2)。例如N = 15，可以写为1 + 2 + 3 + 4 + 5，也可以写为4 + 5 + 6，或7 + 8。如果不能写为若干个连续整数的和，则输出No Solution。

### 输入格式

输入1个数N(3 <= N <= 10^9)。

### 输出格式

输出连续整数中的第1个数，如果有多个按照递增序排列，如果不能分解为若干个连续整数的和，则输出No Solution。

### 输入样例

```
15
```

### 输出样例

```
1
4
7
```

### 题解

数据比较强，$10^9$。如果使用枚举每一个首项来判断是否能得到和的话，复杂度至少是$O(n\sqrt n)$，会$TLE$。

考虑枚举序列的长度$l$ 。设首项为$x$，由等差数列求和公式，有

$$
(2x+l-1)\times l=2n \tag{1}
$$

从而$l \mid 2n$，且$l\le\sqrt {2n}$。

所以只需枚举$[2,\sqrt{2n}]$中的所有$2n$的约数$l$，再由公式$(1)$直接求出相应的$x$即可。

**参考代码**

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main(){
	int n;
	bool flag = 1;
	cin >> n;
	for(int l=sqrt(2*n); l>=2; l--){
		if(2*n%l == 0){
			int ans =  2*n/l+1-l;
			if(ans%2 == 0){
				cout << ans/2 << endl;
				flag = 0;
			}
		}
	}
	if(flag)	cout << "No Solution"; 
	return 0;
}
```

## 小b学进制(数学，进制，枚举的优化)

(from `51nod`)

小b最近在学习进制转化。

对于一个10进制整数n和一个数k，她能快速求出k进制下的n。

如果k进制下的n所有数位都是1，即形如11111111，那么小b就会觉得开心。

现在给定n，请你求出最小的k使得k进制下的n能让小b开心。

### 输入格式

输入一个十进制整数，表示n（没有前导0），其中3≤n≤10^18

### 输出格式

输出一个整数，表示最小的k

### 输入样例

```
4681
```

### 输出样例

```
8
```

### 题解

暴力每一个$k$能$AC$一半的测试点。。其他$TLE$

我个人觉得这题在 `51nod`上给的题解还是很麻烦很神的。。代码是抄来的，因为思路就花了很多时间理解，而且代码还挺难写的。。

![image.png](https://s2.loli.net/2022/08/03/iSNZl85oJnTVEvI.png)

目前记下的知识点就是 `pow(a, x)`函数也可以计算 $x=\frac{1}{k}$的情况，即$k$次根号$a$。

```cpp
#include <iostream>
#include <cmath>
using namespace std;
typedef long long ll;
typedef long double ld;

// sum of (k^0 to k^l)
ld sum(ll k, int l){
	ld mul = 1, sum = 1;
	for(int i = 1; i <= l; i++){ 
		mul *= k;
		sum += mul;
	}
	return sum;
}

int main(){
	ll n, ans = 0;
	bool flag = 1;
	cin >> n;
	for(int l = 60; l > 2; l--){
		for(ll k = ll(pow(n, 1.0/l)+0.5); k >= 2; k--){
			ld s = sum(k, l);
			if(s == n){
				cout << k;
				flag = 0;
				break;
			}
			if(s < n){
				break; 
			}
		}
	}
	if(flag)	cout << n-1;
	return 0;
}
```
