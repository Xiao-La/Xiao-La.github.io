---
layout: post
title: 暑期笔记 | 刷题题解
categories: OI
description: Note
keywords: NOIP, OI, Note
---
有学习新知识中的水题，也有需要思考的好题。暑假的题将会堆这里。

- [[NOIP2001 普及组] 数的计算](#noip2001-普及组-数的计算)
  - [题目描述](#题目描述)
  - [输入格式](#输入格式)
  - [输出格式](#输出格式)
  - [样例 #1](#样例-1)
    - [样例输入 #1](#样例输入-1)
    - [样例输出 #1](#样例输出-1)
  - [提示](#提示)
  - [代码](#代码)
    - [递归（记忆化搜索）](#递归记忆化搜索)
    - [递推](#递推)

## 区间加和问题

将数组$A=\{0\}$上进行 $N$ 次操作$(l,r,s_i)$。第$i$次操作将区间$[l,r]$上的每一个值加上$s_i$，求 $N$ 次操作后数组所有数中的最大值。

可以采用**扫描线**的方法：

首先标记数组：只需将$A[l]$加上$s_i$，将$A[r+1]$减去$s_i$。然后扫描数组时，在每一位上计算出的前缀和就是操作后这一位的实际值。

例如，对$A=\{0,0,0,0,0,0\}$进行操作$(0,3,2)$，先把数组标记成$A=\{2,0,0,0,-2,0\}$，扫描时计算前缀和：$\{2,2,2,2,0,0\}$。

**参考代码**

```cpp
#include <bits/stdc++.h>
using namespace std;

int A[1005];

int main(){
	int N,l,r,s,max_n=0;
	cin >> N;
	for(int i=1;i<=N;i++){
		cin >> l >> r >> s;
		A[l]+=s;
		A[r+1]-=s;
	} //标记 
	for(int i=1;i<=1005;i++){
		A[i]+=A[i-1];
		max_n=max(max_n,A[i]);
	}//扫描，加前缀和 
	cout << max_n;
	return 0;
}
```

时间复杂度：$O(n)$

## [NOIP2001 普及组] 数的计算

[洛谷 P1028](https://www.luogu.com.cn/problem/P1028)

### 题目描述

我们要求找出具有下列性质数的个数（包含输入的正整数 $n$）。

先输入一个正整数 $n$（$n \le 1000$），然后对此正整数按照如下方法进行处理：

1. 不作任何处理；
2. 在它的左边拼接一个正整数，但该正整数不能超过原数，或者是上一个被拼接的数的一半；
3. 加上数后，继续按此规则进行处理，直到不能再加正整数为止。

### 输入格式

一行，一个正整数 $n$（$n \le 1000$）。

### 输出格式

一个整数，表示具有该性质数的个数。

### 样例 #1

#### 样例输入 #1

```
6
```

#### 样例输出 #1

```
6
```

### 提示

**【样例解释】**

满足条件的数为：$6$，$16$，$26$，$126$，$36$，$136$。

**【题目来源】**

NOIP 2001 普及组第一题

### 代码

#### 递归（记忆化搜索）

暴力搜索的思路为：当调用 `f(n)`时，枚举 `1~(n/2)` 中的数(`i`)，然后再调用 `f(i)`，直到 `f(1)`直接返回。每一次调用都让计数器 `t++`（因为每调用一次函数就意味着有一个合法答案）。

但是如果不记忆化的话，上述思路会TLE(因为 `f(999)=1955133450`，意味着要调用1955133450次函数)。不过实际考试中可以考虑打表。

更好的选择是写成记忆化，也就是以下代码：

```c++
#include <bits/stdc++.h>
using namespace std;

int t,memory[1001],i;

int f(int n){
    t=1;//这个数本身就算一个答案
    for(i=1;i<=n/2;i++){
        if(!memory[i])  memory[i]=f(i);
        t+=memory[i];
    }
    return t;
}

int main(){
    int n;
    cin >> n;
    cout << f(n);
    return 0;
}
```

添加了 `memory`数组进行记忆。注意到，若写记忆化算法，函数需要有返回值，而不采用暴力计数器。这其实算是比较典型的递归算法。

写成递归公式为：

$$
f(n)=\begin{cases}
\sum\limits_{i=1}^{n/2}f(i) & (n>1)\\
1 & (n=1)
\end{cases}
$$

#### 递推

其实这题的最好写法是递推。

可以推出，递推公式为：

$$
f[1]=1\\
f[n]=1+\sum\limits_{i=1}^{n/2}f[i]
$$

这样一来，代码就好写多了。

```c++
#include <bits/stdc++.h>
using namespace std;

int f[1001];

int main(){
    f[1]=1;
    int n;
    cin >> n;
    for(int i=2;i<=n;i++){
        for(int j=1;j<=i/2;j++){
            f[i]+=f[j];
        }
        f[i]++;
    }
    cout << f[n];
    return 0;
}
```
