---
layout: post
title: OI笔记 | 重链剖分笔记
categories: Note
description: Note
keywords: NOIP, OI, Note, tree, graph
---

## 重链剖分

模板题：[洛谷 P3384](https://www.luogu.com.cn/problem/P3384)

**重链剖分**可以把树分割成若干条链，且保证划分出的每条链上的节点 dfs 序连续，从而可以用**维护序列的数据结构**（如线段树）来维护树的路径上的信息。

我们定义 $hson(x)$ 为 $x$ 的**重儿子**，即 $x$ 的所有儿子中，子树大小最大的。

从一个节点到它的重子节点的边称为**重边**。若干条首尾衔接的重边构成**重链**。

只需要用两次简单的 dfs 就可以实现树剖。

第一次 dfs 中，我们需要求出每个节点的 **重儿子** $hson(x)$、**深度** $dep(x)$、**以它为根的子树大小** $siz(x)$、**父亲** $fa(x)$。

第二次 dfs 中，需要 **优先** dfs 每个节点的重儿子，这可以让同一条重链上的点的 dfs 序连续。我们需要求出每个节点的 **dfs序** $dfn(x)$、**所在重链的深度最小的节点** $top(x)$。顺带着把点权赋值到序列上，即 $a_{dfn(x)}\gets v_x$。

到这一步树剖其实已经完成，已经可以用这些信息求 $\operatorname{LCA}(x,y)$ 了。实现就是将 $top$ 深度较大的节点往上跳到 $fa(top(x))$，直到两个节点在同一条重链上。代码如下：

```cpp
int lca(int x, int y) {
    while(top[x] != top[y]) {
        if(dep[top[x]] > dep[top[y]])   x = fa[top[x]];
        else    y = fa[top[y]];
    }
    return dep[x] < dep[y] ? x : y;
}
```

考虑模板题中的信息维护，我们用一棵**线段树**来维护权值和。

先看操作 3 和 4，比较简单：

- `3 x z`，表示将以 $x$ 为根节点的子树内所有节点值都加上 $z$。

- `4 x` 表示求以 $x$ 为根节点的子树内所有节点值之和

由于子树内的 $dfn$ 也是连续的，所以对于子树内的修改与查询，我们只需要直接对区间 $[dfn(x),dfn(x)+siz(x)-1]$ 进行操作即可。

再看操作 1 和 2：

- `1 x y z`，表示将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$。

- `2 x y`，表示求树从 $x$ 到 $y$ 结点最短路径上所有节点的值之和。

我们像 LCA 一样，每次让将 $top$ 深度较大的节点往上跳到 $fa(top(x))$，直到两个节点在同一条重链上。

每次跳的时候都 修改/查询 区间 $[dfn(top(x)),dfn(x)]$（$dep(top(x))>dep(top(y))$）。

最后在同一条重链上时再 修改/查询 区间 $[dfn(x), dfn(y)]$（$dep(x)<dep(y)$）。

注意这题每一步都要取模，我有一个地方没加取模然后调了半个小时。而且把数据下载下来调居然在 dfs 时就爆栈了，加了编译选项才正常。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAX_N = 1e5 + 10;
int n, m, rt, MOD, dfncnt;
int v[MAX_N], top[MAX_N], hson[MAX_N], dep[MAX_N], fa[MAX_N], siz[MAX_N], dfn[MAX_N];
int a[MAX_N], d[MAX_N << 2], b[MAX_N << 2];
vector<int> G[MAX_N];

inline ll read() {...}
inline void write(ll x) {...}
void dfs1(int u, int pre) {
    hson[u] = -1;
    siz[u] = 1;
    for(int i = 0; i < G[u].size(); i++) {
        int v = G[u][i];
        if(v == pre) continue;
        dep[v] = dep[u] + 1;
        fa[v] = u;
        dfs1(v, u);
        siz[u] += siz[v];
        if(hson[u] == -1 || siz[v] > siz[hson[u]])  hson[u] = v;
    }
}
void dfs2(int u, int tp) {
    top[u] = tp;
    dfn[u] = ++dfncnt;
    a[dfncnt] = v[u];
    if(hson[u] == -1)   return;
    dfs2(hson[u], tp);
    for(int i = 0; i < G[u].size(); i++) {
        int v = G[u][i];
        if(v != fa[u] && v != hson[u])  dfs2(v, v);
    }
}

inline int lc(int p) {return (p << 1);}
inline int rc(int p) {return (p << 1) | 1;}
inline int mid(int s, int t) {return (s + ((t - s) >> 1));}
inline void pu(int p) {d[p] = (d[lc(p)] + d[rc(p)]) % MOD;}
inline void pd(int p, int s, int t) {
    if(b[p]) {
        int m = mid(s, t);
        (d[lc(p)] += (m - s + 1) * b[p]) %= MOD;
        (d[rc(p)] += (t - m) * b[p]) %= MOD;
        (b[lc(p)] += b[p]) %= MOD;
        (b[rc(p)] += b[p]) %= MOD;
        b[p] = 0;
    }
}
void build_tree(int s, int t, int p) {
    if(s == t) {d[p] = a[s]; return;}
    int m = mid(s, t);
    build_tree(s, m, lc(p));
    build_tree(m + 1, t, rc(p));
    pu(p);
}
void update(int s, int t, int p, int l, int r, int k) {
    if(l <= s && t <= r) {
        (d[p] += (t - s + 1) * k) %= MOD;
        (b[p] += k) %= MOD;
        return;
    }
    pd(p, s, t);
    int m = mid(s, t);
    if(l <= m)  update(s, m, lc(p), l, r, k);
    if(r > m)   update(m + 1, t, rc(p), l, r, k);
    pu(p);
}
int query(int s, int t, int p, int l, int r) {
    if(l <= s && t <= r)    return d[p];
    pd(p, s, t);
    int m = mid(s, t), ret = 0;
    if(l <= m)  (ret += query(s, m, lc(p), l, r)) %= MOD;
    if(r > m)   (ret += query(m + 1, t, rc(p), l, r)) %= MOD;
    return ret;
}
void update_path(int x, int y, int k) {
    while(top[x] != top[y]) {
        if(dep[top[x]] < dep[top[y]])   swap(x, y);
        update(1, n, 1, dfn[top[x]], dfn[x], k);
        x = fa[top[x]];   
    }
    if(dep[x] > dep[y]) swap(x, y);
    update(1, n, 1, dfn[x], dfn[y], k);
}
int query_path(int x, int y) {
    int ret = 0;
    while(top[x] != top[y]) {
        if(dep[top[x]] < dep[top[y]])   swap(x, y);
        (ret += query(1, n, 1, dfn[top[x]], dfn[x])) %= MOD;
        x = fa[top[x]];
    }
    if(dep[x] > dep[y]) swap(x, y);
    (ret += query(1, n, 1, dfn[x], dfn[y])) %= MOD;
    return ret;
}
int main() {
    n = read(), m = read(), rt = read(), MOD = read();
    for(int i = 1; i <= n; i++) v[i] = read();
    for(int i = 1; i <= n - 1; i++) {
        int u = read(), v = read();
        G[u].push_back(v), G[v].push_back(u);
    }
    dfs1(rt, 0);
    dfs2(rt, rt);
    build_tree(1, n, 1);
    while(m--) {
        int op = read();
        if(op == 1) {
            int x = read(), y = read(), k = read();
            update_path(x, y, k);
        }
        else if(op == 2) {
            int x = read(), y = read();
            write(query_path(x, y));
            putchar('\n');
        }
        else if(op == 3) {
            int x = read(), k = read();
            update(1, n, 1, dfn[x], dfn[x] + siz[x] - 1, k);
        }
        else {
            int x = read();
            write(query(1, n, 1, dfn[x], dfn[x] + siz[x] - 1));
            putchar('\n');
        }
    }
    return 0;
}
```

## 树剖的换根

等学了再来补笔记，可能等 NOIP 之后吧。
