---
layout: post
title: OI笔记 | 2022.9-10 基础模板合集（线段树、图论等）
categories: OI
description: Note
keywords: NOIP, OI, Note, SegmentTree, Graph, dijkstra
---

- [Exgcd模板题](#exgcd模板题)
	- [题解](#题解)
- [对顶堆](#对顶堆)
	- [中位数](#中位数)
	- [黑匣子](#黑匣子)
- [线段树](#线段树)
	- [模板1](#模板1)
		- [题解](#题解-1)
	- [模板2](#模板2)
		- [题解](#题解-2)
	- [[例题] 守墓人](#例题-守墓人)
		- [题解](#题解-3)
- [Kruskal 求最小生成树](#kruskal-求最小生成树)
	- [[例题] 苗条的生成树(Slim Span)](#例题-苗条的生成树slim-span)
		- [题解](#题解-4)
- [dijkstra](#dijkstra)
	- [题解](#题解-5)
	- [例题 邮递员送信](#例题-邮递员送信)
		- [题解](#题解-6)
- [拓扑排序](#拓扑排序)
	- [题解](#题解-7)
- [并查集](#并查集)
	- [模板](#模板)
		- [题解](#题解-8)
	- [利用并查集求最小环](#利用并查集求最小环)
		- [题解](#题解-9)
- [单调栈模板](#单调栈模板)
	- [题解](#题解-10)
	- [[例题] 积水面积](#例题-积水面积)
		- [题解](#题解-11)


## Exgcd模板题

[洛谷 P5656](https://www.luogu.com.cn/problem/P5656)

给定不定方程
$ax+by=c$。

若该方程无整数解，输出 $−1$。
若该方程有整数解，且有正整数解，则输出其正整数解的数量，所有正整数解中 $x$ 的最小值，所有正整数解中 $y$ 的最小值，所有正整数解中 $x$ 的最大值，以及所有正整数解中 $y$ 的最大值。
若方程有整数解，但没有正整数解，你需要输出所有整数解中 $x$ 的最小正整数值， $y$ 的最小正整数值。

### 题解

整理自**dengyaotriangle**的题解。

由裴蜀定理，我们知道该方程有整数解的充要条件为$gcd(a, b) \mid c$，这样我们可以特判出第一种输出$-1$的情况。

并且我们知道$exgcd$算法可以算出方程$ax+by=gcd(a, b)$的一对特解$(x_0, y_0)$，证明见[OI-wiki](https://oi-wiki.org/math/number-theory/gcd/#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)。具体实现如下：

```cpp
ll exgcd(ll a, ll b, ll &x, ll &y) {
	if(b == 0) {
		x = 1;
		y = 0;
		return a;
	}	
	ll d = exgcd(b, a % b, x, y);
	ll t = x;
	x = y;
	y = t - (a / b) * y;
	return d;
}
```
方程$ax+by=gcd(a, b)$的两边只要同时乘上$\frac{c}{gcd(a,b)}$，就能得到原方程$ax+by=c$的一组特解$(x_1, y_1)$，其中$x_1 = \frac{cx_0}{gcd(a,b)}$，$y_1 = \frac{cy_0}{gcd(a,b)}$。

考虑如何通过特解推出最小整数解。

原方程等价为$a(x+db)+b(y-da) = c$，其中$d\in Z$，那么$(x+db,y-da)$也是原方程的一组解。

更进一步，如果$d$取到最小值$\frac{1}{gcd(a,b)}$(可以证明这是满足整除性质的最小$d$)，则容易看出目前的解$(x+s\times db,y-s\times da)$当$s\in Z$时能取遍原方程的所有整数解。

考虑题目设问。

如果 $x>0$，则$x_1+db>0$，则$d > - \frac{b}{x_1}$。

如果 $y>0$，则$y_1-da>0$，则$d < \frac{a}{y_1}$。

则 $d$ 的范围为$[\lceil\frac{-x_1+1}{d}\rceil\ , \lfloor\frac{y_1-1}{d}\rfloor]$

如果$d$的范围为空集，则正无整数解，最小的一正一负为解为$（x_1+d_{min}b, y_1-d_{min}）$。

如果不为空集，$x$ 的最大值和 $y$ 的最小值都是在 d 最大时取到，而 $x$ 的最小值和 $y$ 的最大值都是在 $s$ 最小时取到，直接计算即可。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll read() {...}
void write(ll x) {...}
ll gcd(ll a, ll b) {...}
ll exgcd(ll a, ll b, ll &x, ll &y) {...}

int main() {
	int T = read();
	while(T--) {
		ll a = read(), b = read(), c = read(), x, y;
		ll d = gcd(a, b);
		if(c % d) {
			write(-1); putchar('\n');
			continue;
		}
		exgcd(a, b, x, y);
		x *= c / d, y *= c / d;
		ll dx = b / d, dy = a / d;
		ll mins = ceil((1 - x) * 1.0 / dx);
		ll maxs = floor((y - 1) * 1.0 / dy);
		if(maxs < mins) {
			write(x + dx * mins); putchar(' ');
			write(y - dy * maxs);
		}
		else {
			write(maxs - mins + 1); putchar(' ');
			write(x + dx * mins); putchar(' ');
			write(y - dy * maxs); putchar(' ');
			write(x + dx * maxs); putchar(' ');
			write(y - dy * mins);
		}
		putchar('\n');
	}
	return 0;
}
```

## 对顶堆

对顶堆是简单却好用的数据结构。以下内容来自 [oi-wiki](https://oi-wiki.org/ds/binary-heap/#%E5%AF%B9%E9%A1%B6%E5%A0%86)：

对顶堆由一个大根堆与一个小根堆组成，小根堆维护大值即前 $k$ 大的值（包含第 $k$ 个），大根堆维护小值即比第 $k$ 大数小的其他数。

这两个堆构成的数据结构支持以下操作：

1. 维护：当小根堆的大小小于 $k$ 时，不断将大根堆堆顶元素取出并插入小根堆，直到小根堆的大小等于 $k$；当小根堆的大小大于 $k$ 时，不断将小根堆堆顶元素取出并插入大根堆，直到小根堆的大小等于 $k$；

2. 插入元素：若插入的元素大于等于小根堆堆顶元素，则将其插入小根堆，否则将其插入大根堆，然后维护对顶堆；

3. 查询第 $k$ 大元素：小根堆堆顶元素即为所求；

4. 删除第 $k$ 大元素：删除小根堆堆顶元素，然后维护对顶堆；

5. $k$ 值 $+1/-1$：根据新的 $k$ 值直接维护对顶堆。

其中查询是 $O(1)$ 的，维护是 $O(\log n)$ 的。

### 中位数

[洛谷 P1168](https://www.luogu.com.cn/problem/P1168)

要求每次插入一个数字，当序列中数字数量为奇数时，输出序列的中位数。

很裸的对顶堆题，只要令 $k=\frac{n + 1}{2}$ 即可。时间复杂度 $O(n\log n)$。

其实最开始做是用 `vector` + 二分做的， 时间复杂度是 $O(n^2 \log n)$，居然也能过，很离谱，可能是因为 STL 的常数太低了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
priority_queue<int> p; // 大根堆
priority_queue<int, vector<int>, greater<int>> q;// 小根堆
inline ll read() {...}
inline void write(ll x) {...}

int main() {
	int n = read();
	int tmp = read(), mid = tmp;
	write(mid); putchar('\n');
	for(int i = 2; i <= n; i++) {
		tmp = read();
		if(tmp > mid)	q.push(tmp);
		else	p.push(tmp);
		if(i % 2) {
			while(p.size() != q.size()) {
				if(p.size() > q.size()) {
					q.push(mid);
					mid = p.top();
					p.pop();
				}
				else {
					p.push(mid);
					mid = q.top();
					q.pop();
				}
			}
			write(mid);
			putchar('\n');
		}
	}
	return 0;  
}
```

### 黑匣子

[洛谷 P1801](https://www.luogu.com.cn/problem/P1801)

要求实现两种操作：向序列中插入一个数字 以及 查询序列中第 $k$ 小的值。每次查询时都让 $k+1$。

注意上面介绍的是维护第 $k$ 大的值，而这道题是维护第 $k$ 小的值。所以我们应该注意的是大根堆的大小与 $k$ 的关系，因为大根堆维护的才是小值。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAX_N = 200005;
ll a[MAX_N];
priority_queue<ll> p;
priority_queue<ll, vector<ll>, greater<ll>> q;
inline ll read() {...}
inline void write(ll x) {...}

int main() {
	int k = 0, o = 1, m = read(), n = read();
	for(int i = 1; i <= m; i++)	a[i] = read();
	for(int i = 1; i <= n; i++) {
		int t = read();
		for(int x = o; x <= t; x++) {
			if(q.empty() || a[x] < p.top())	p.push(a[x]);
			else	q.push(a[x]);
		}
		o = t + 1;
		k++;
		while(p.size() > k)	q.push(p.top()), p.pop();
		while(p.size() < k)	p.push(q.top()), q.pop();
		write(p.top());
		putchar('\n');
	}
	return 0;  
}
```


## 线段树

[OI-Wiki 上线段树的条目](https://oi-wiki.org/ds/seg/)

### 模板1

[洛谷 P3372](https://www.luogu.com.cn/problem/P3372)

维护一个线段树，支持对一个数列进行下面两种操作：

1. 将某区间每一个数加上 $k$。
2. 求出某区间每一个数的和。

$1 \le n, m \le {10}^5$， 其中 $n$ 为数列长度， $m$ 为操作次数。

#### 题解

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAX_N = 1e5+7;
ll a[MAX_N], d[MAX_N * 3], b[MAX_N * 3];

inline ll read() {...}
inline void write(ll x) {...}
void build_tree(int s, int t, int p) {
	if(s == t) {d[p] = a[s]; return;}
	int m = s + ((t - s) >> 1);
	build_tree(s, m, p * 2), build_tree(m + 1, t, p * 2 + 1);
	d[p] = d[p * 2] + d[p * 2 + 1];	
}
void update(int l, int r, ll k, int s, int t, int p) {
	if(l <= s && t <= r) {d[p] += (t - s + 1) * k; b[p] += k; return;}
	int m = s + ((t - s) >> 1);
	if(b[p] && s != t) {
		d[p * 2] += (m - s + 1) * b[p], d[p * 2 + 1] += (t - m) * b[p];
		b[p * 2] += b[p], b[p * 2 + 1] += b[p];
		b[p] = 0; 
	}
	if(l <= m)	update(l, r, k, s, m, p * 2);
	if(r > m)	update(l, r, k, m + 1, t, p * 2 + 1);
	d[p] = d[p * 2] + d[p * 2 + 1];
}

ll query(int l, int r, int s, int t, int p) {
	if(l <= s && t <= r)	return d[p];
	int m = s + ((t - s) >> 1);
	if(b[p] && s != t) {
		d[p * 2] += (m - s + 1) * b[p], d[p * 2 + 1] += (t - m) * b[p];
		b[p * 2] += b[p], b[p * 2 + 1] += b[p];
		b[p] = 0; 
	}
	ll sum = 0;
	if(l <= m)	sum += query(l, r, s, m, 2 * p);
	if(r > m)	sum += query(l, r, m + 1, t, 2 * p + 1);
	return sum;
}

int main() {
	int n = read(), m = read(), l, r, op;
	ll k;
	for(int i = 1; i <= n; i++)	a[i] = read();
	build_tree(1, n, 1);
	for(int i = 1; i <= m; i++) {
		op = read(), l = read(), r = read();
		if(op == 1)	{k = read(); update(l, r, k, 1, n, 1);}
		else {write(query(l, r, 1, n, 1)); putchar('\n');}
	}
	return 0;
}
```

### 模板2

[洛谷 P3373](https://www.luogu.com.cn/problem/P3373)

维护一个线段树，支持对一个数列进行下面两种操作：

1. 将某区间每一个数乘上 $k$。
1. 将某区间每一个数加上 $k$。
2. 求出某区间每一个数的和。

$1 \le n, m \le {10}^5$， 其中 $n$ 为数列长度， $m$ 为操作次数。

#### 题解

其实就是模板1加上一个乘法标记。对于区间的乘 $k$ 操作，我们把乘法标记和加法标记都乘上 $k$；而区间加只把加法标记加上 $k$。

注意在做 `push_down` 的时候往往是先做完乘在做加，这样能够满足乘法分配率。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAX_N = 1e5+7;
ll a[MAX_N], d[MAX_N * 3], at[MAX_N * 3], mt[MAX_N * 3];
int n, m, MOD;

inline ll read() {...}
inline void write(ll x) {...}

void up(int p) {d[p] = (d[(p << 1)] + d[(p << 1) | 1]) % MOD;}
void build_tree(int s, int t, int p) {
	at[p] = 0, mt[p] = 1;
	if(s == t) {d[p] = a[s]; return;}
	int m = s + ((t - s) >> 1);
	build_tree(s, m, (p << 1));
	build_tree(m + 1, t, (p << 1) | 1);
	up(p);
}

void push_down(int p, int s, int t) {
	int lc = (p << 1), rc = (p << 1) | 1;
	int m = s + ((t - s) >> 1);
	if(mt[p] != 1) {
		mt[lc] = (mt[lc] * mt[p]) % MOD;
		mt[rc] = (mt[rc] * mt[p]) % MOD;
		at[lc] = (at[lc] * mt[p]) % MOD;
		at[rc] = (at[rc] * mt[p]) % MOD;
		d[lc] = (d[lc] * mt[p]) % MOD;
		d[rc] = (d[rc] * mt[p]) % MOD;
		mt[p] = 1;
	}
	if(at[p]) {
		at[lc] = (at[lc] + at[p]) % MOD;
		at[rc] = (at[rc] + at[p]) % MOD;
		d[lc] = (d[lc] + at[p] * (m - s + 1)) % MOD;
		d[rc] = (d[rc] + at[p] * (t - m)) % MOD;
		at[p] = 0;
	}
}

void ud_mul(int l, int r, int s, int t, int p, ll k) {
	if(l <= s && t <= r) { 
		d[p] = (d[p] * k) % MOD;
		mt[p] = (mt[p] * k) % MOD;
		at[p] = (at[p] * k) % MOD;
		return;
	}
	int m = s + ((t - s) >> 1);
	if(s != t)	push_down(p, s, t);
	if(l <= m)	ud_mul(l, r, s, m, (p << 1), k);
	if(r > m)	ud_mul(l, r, m + 1, t, (p << 1) | 1, k);
	up(p);
}

void ud_add(int l, int r, int s, int t, int p, ll k) {
	if(l <= s && t <= r) {
		d[p] = (d[p] + k * (t - s + 1)) % MOD;
		at[p] = (at[p] + k) % MOD;
		return;
	}	
	int m = s + ((t - s) >> 1);
	if(s != t)	push_down(p, s, t);
	if(l <= m)	ud_add(l, r, s, m, (p << 1), k);
	if(r > m)	ud_add(l, r, m + 1, t, (p << 1) | 1, k);
	up(p);
}

ll query(int l, int r, int s, int t, int p) {
	if(l <= s && t <= r) {return d[p];}
	if(s != t)	push_down(p, s, t);
	int m = s + ((t - s) >> 1);
	ll sum = 0;
	if(l <= m)	sum = (sum + query(l, r, s, m, (p << 1))) % MOD;
	if(r > m)	sum = (sum + query(l, r, m + 1, t, (p << 1) | 1)) % MOD;
	return sum;
}

int main() {
	n = read(), m = read(), MOD = read();
	int x, y; ll k;
	for(int i = 1; i <= n; i++)	a[i] = read();
	build_tree(1, n, 1);
	for(int i = 1; i <= m; i++) {
		int op = read(), x = read(), y = read();
		if(op == 1)	{k = read(); ud_mul(x, y, 1, n, 1, k);}
		else if(op == 2)	{k = read(); ud_add(x, y, 1, n, 1, k);}
		else {write(query(x, y, 1, n, 1)); putchar('\n');}
	}
	return 0;
}
```

### [例题] 守墓人

[洛谷 P2357](https://www.luogu.com.cn/problem/P2357)

墓地分为主墓碑和次要墓碑， 主墓碑只能有 $1$ 个， 守墓人把他记为 $1$ 号， 而次要墓碑有 $n-1$ 个，守墓人将之编号为 $2,3\dots n$，所以构成了一个有 $n$ 个墓碑的墓地。每个墓地都有一个风水值。

守墓人会有几个操作：

1. 将 $[l,r]$ 这个区间所有的墓碑的风水值增加 $k$

2. 将主墓碑的风水值增加 $k$

3. 将主墓碑的风水值减少 $k$

4. 统计 $[l,r]$ 这个区间所有的墓碑的风水值之和

5. 求主墓碑的风水值

数据范围：$1\leq n,f\leq 2 \times 10^5$，答案不超过 64 位整数。


#### 题解

裸的线段树模板，主要是练习一遍写法。其实线段树模板还是很好背的。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAX_N = 2e5 + 5;
ll a[MAX_N], d[MAX_N * 3], b[MAX_N * 3];
inline ll read() {...}
inline void write(ll x) {...}
inline int lc(int p) {return (p << 1);}
inline int rc(int p) {return (p << 1) | 1;}
inline void up(int p) {d[p] = d[lc(p)] + d[rc(p)];}
void push_down(int p, int s, int t) {
	if(b[p]) {
		int m = s + ((t - s) >> 1);
		b[lc(p)] += b[p], b[rc(p)] += b[p];
		d[lc(p)] += (m - s + 1) * b[p], d[rc(p)] += (t - m) * b[p];
		b[p] = 0; 
	}
}
void build_tree(int s, int t, int p) {
	if(s == t) {d[p] = a[s]; return;}
	int m = s + ((t - s) >> 1);
	build_tree(s, m, lc(p));
	build_tree(m + 1, t, rc(p));
	up(p);
} 
void update(int l, int r, int s, int t, int p, ll k) {
	if(l <= s && t <= r) {
		d[p] += k * (t - s + 1);
		b[p] += k;
		return;
	}
	if(s != t)	push_down(p, s, t);
	int m = s + ((t - s) >> 1);
	if(l <= m)	update(l, r, s, m, lc(p), k);
	if(r > m)	update(l, r, m + 1, t, rc(p), k);
	up(p);	
}
ll query(int l, int r, int s, int t, int p) {
	if(l <= s && t <= r) {return d[p];}
	if(s != t)	push_down(p, s, t);
	int m = s + ((t - s) >> 1);
	ll sum = 0;
	if(l <= m)	sum += query(l, r, s, m, lc(p));
	if(r > m)	sum += query(l, r, m + 1, t, rc(p));
	return sum;	
}

int main() {
	int n = read(), f = read(), l, r;
	ll k;
	for(int i = 1; i <= n; i++)	a[i] = read();
	build_tree(1, n, 1);
	for(int i = 1; i <= f; i++) {
		int op = read();
		if(op == 1) {
			l = read(), r = read(), k = read();	
			if(l == 1)	a[1] += k;
			update(l, r, 1, n, 1, k);
		}
		else if(op == 2 || op == 3) {
			k = read();
			if(op == 3)	k = -k;
			update(1, 1, 1, n, 1, k);
			a[1] += k;
		}
		else if(op == 4) {
			l = read(), r = read();
			write(query(l, r, 1, n, 1));	
			putchar('\n');
		}
		else {
			write(a[1]);
			putchar('\n');
		}
	}	
	return 0;
}
```

## Kruskal 求最小生成树

[洛谷 P3366](https://www.luogu.com.cn/problem/solution/P3366)

将边按权值从小到大排序后顺序枚举。如果一条边的 $u$ 和 $v$ 还没有连通，贪心地加上这条边。

判断 $u$ 和 $v$ 是否连通可以用并查集。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAX_N = 2e5 + 10;
struct edge {
	int u, v, w;
	bool operator < (const edge &t) const {
		return w < t.w;
	}
} a[MAX_N];
int f[MAX_N];
inline ll read() {...}
inline void write(ll x) {...}
int find(int x) {
	if(f[x] == x)	return x;
	return (f[x] = find(f[x]));
}
int main() {
	int n = read(), m = read(), cnt = 0;
	ll ans = 0;
	for(int i = 1; i <= n; i++)	f[i] = i;
	for(int i = 1; i <= m; i++)	a[i].u = read(), a[i].v = read(), a[i].w = read();
	sort(a + 1, a + m + 1);
	for(int i = 1; i <= m; i++) {
		int fu = find(a[i].u), fv = find(a[i].v);
		if(fu != fv){
			ans += a[i].w;
			f[fu] = fv;
			if((++cnt) == n - 1)	break;
		}
	}
	if(cnt == n - 1)	write(ans);
	else	printf("orz");
	return 0;
}
```
### [例题] 苗条的生成树(Slim Span)

[UVA1395](https://www.luogu.com.cn/problem/UVA1395)

求所有生成树中最大边权与最小边权差最小的，输出它们的差值。

#### 题解

紫书上的解法。将边按边权排序，从小到大枚举 $l$，从 $l$ 到 $n$ 枚举 $r$，不断将 $r$ 加入并查集，直到连成一个生成树，枚举下一个 $l$ 并维护答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAX_N = 2e5 + 10, INF = (1 << 30);
struct edge {
	int u, v, w;
	bool operator < (const edge &t) const {return w < t.w;}
} g[MAX_N];
int f[MAX_N], n, m, cnt;
inline ll read() {...}
inline void write(ll x) {...}
int find(int x) {return f[x] == x ? x : (f[x] = find(f[x]));}
int main() {
	while(n = read()) {
		m = read();
		int ans = INF;
		for(int i = 1; i <= m; i++)	g[i].u = read(), g[i].v = read(), g[i].w = read();
		sort(g + 1, g + m + 1);
		for(int i = 1; i <= m; i++) {
			cnt = 0;
			for(int i = 1; i <= n; i++)	f[i] = i;
			for(int j = i; j <= m; j++) {
				int fu = find(g[j].u), fv = find(g[j].v);
				if(fu != fv) {
					f[fu] = fv;
					if((++cnt) == n - 1) {
						ans = min(ans, g[j].w - g[i].w);
						break;
					}
				}
			}
		}
		write(ans == INF ? -1 : ans); putchar('\n');
	}
	return 0;
}
```



## dijkstra

[洛谷 P4779](https://www.luogu.com.cn/problem/P4779)

给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。

数据保证你能从 $s$ 出发到任意点。

### 题解

dijkstra 的过程如下：

1. 初始化 `d[s]=0`，其它 `d[i]=INF`。清除 `vis` 数组。

2. 选出 `d` 最小的节点 `u`（`vis[u]==0`）。

3. 遍历 `u` 的所有出边 `(u,v,w)`，更新 `d[v]=min(d[v],d[u]+w)`。

4. 如果没有完成，回到第 2 步。

用堆来优化第 2 步的复杂度。时间复杂度：$O((n+m)\log n)$。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int MAX_N = 1e5 + 10, INF = (1ll << 31) - 1;
struct Edge {int u, v, w;};
vector<Edge> edges;
vector<int> G[MAX_N];
int d[MAX_N], n, m, s;
bool vis[MAX_N];
inline void AddEdge(int u, int v, int w) {
	edges.push_back({u, v, w});
	G[u].push_back(edges.size() - 1); // 存的是边的标号
}
inline void dijkstra() {
	priority_queue<pii, vector<pii>, greater<pii>> q;
	for(int i = 1; i <= n; i++)	d[i] = INF;
	d[s] = 0;
	q.push({0, s});
	while(!q.empty()) {
		int u = q.top().second; q.pop();
		if(vis[u])	continue;
		vis[u] = true;
		for(int i = 0; i < G[u].size(); i++) {
			int v = edges[G[u][i]].v, w = edges[G[u][i]].w;
			if(d[u] + w < d[v]) {
				d[v] = d[u] + w;
				q.push({d[v], v});	
			}
		}
	}
}
inline ll read() {...}
inline void write(ll x) {...}
int main() {
	n = read(), m = read(), s = read();
	for(int i = 1; i <= m; i++) {
		int u = read(), v = read(), w = read();
		AddEdge(u, v, w);
	}
	dijkstra();
	for(int i = 1; i <= n; i++)	write(d[i]), putchar(' ');
	return 0;
}
```

### 例题 邮递员送信

[洛谷 P1629](https://www.luogu.com.cn/problem/P1629)

有一个邮递员要送东西，邮局在节点 $1$。他总共要送 $n-1$ 样东西，其目的地分别是节点 $2$ 到节点 $n$。由于这个城市的交通比较繁忙，因此所有的道路都是单行的，共有 $m$ 条道路。这个邮递员每次只能带一样东西，并且**运送每件物品过后必须返回邮局**。求送完这 $n-1$ 样东西并且**最终回到邮局**最少需要的时间。

#### 题解

我们对原图跑一遍 dijkstra，再对反图跑一遍 dijkstra。这是一个比较重要的技巧：对多到一的最短路，考虑进行“反向建边”。

对于反图的存储，我们可以在原图的编号上加上 $n$，直接存在原图上。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int MAX_N = 2e3 + 10, INF = (1ll << 31) - 1;
struct Edge {int u, v, w;};
vector<Edge> edges;
vector<int> G[MAX_N];
int d[MAX_N], n, m;
bool vis[MAX_N];
inline void AddEdge(int u, int v, int w){edges.push_back({u, v, w}); G[u].push_back(edges.size() - 1);}
inline void dijkstra(int s) {
	priority_queue<pii, vector<pii>, greater<pii>> q;
	for(int i = 1; i <= 2 * n; i++)	d[i] = INF;
	d[s] = 0; q.push({0, s});
	while(!q.empty()) {
		int u = q.top().second; q.pop();
		if(vis[u])	continue;
		vis[u] = true;
		for(int i = 0; i < G[u].size(); i++) {
			int v = edges[G[u][i]].v, w = edges[G[u][i]].w;
			if(d[u] + w < d[v]) {
				d[v] = d[u] + w;
				q.push({d[v], v});
			} 
		}
	}
}

inline ll read() {...}
inline void write(ll x) {...}

int main() {
	ll ans = 0;
	n = read(), m = read();
	for(int i = 1; i <= m; i++)	{
		int u = read(), v = read(), w = read();
		AddEdge(u, v, w);
		AddEdge(v + n, u + n, w);
	}
	dijkstra(1);
	for(int i = 2; i <= n; i++)	ans += d[i];
	dijkstra(n + 1);
	for(int i = n + 2; i <= n * 2; i++)	ans += d[i];	
	write(ans);
	return 0;
}
```

## 拓扑排序

[洛谷 P1347](https://www.luogu.com.cn/problem/P1347)

一个不同的值的升序排序数列指的是一个从左到右元素依次增大的序列，例如，一个有序的数列 $A,B,C,D$ 表示$A<B,B<C,C<D$。在这道题中，我们将给你一系列形如 $A<B$ 的关系，并要求你判断是否能够根据这些关系确定这个数列的顺序。

若根据前 $x$ 个关系即可确定这 $n$ 个元素的顺序 `yyy..y`（如 `ABC`），输出

`Sorted sequence determined after xxx relations: yyy...y.`

若根据前 $x$ 个关系即发现存在矛盾（如 $A<B,B<C,C<A$），输出

`Inconsistency found after x relations.`

若根据这 $m$ 个关系无法确定这 $n$ 个元素的顺序，输出

`Sorted sequence cannot be determined.`

### 题解

考虑若 $A<B$，则连一条有向边 $A\to B$。如果能成功使用 Kahn 算法进行拓扑排序，那么序列的顺序就确定了。

Kahn 算法的伪代码如下：

```
L ← 存储拓扑排序后的节点顺序
S ← 入度为零的节点队列
若 S 非空
    从 S 的前端取出 u 并弹出
    将 u 插入 L
    枚举 u 为入边的所有边 (u,v)
        删除 (u,v)
        如果 v 入度为 0
            将 v 插入 S
如果图还有边
    拓扑排序失败
否则
    返回 L
```

对应到这一题，我们每建一条边就要进行拓扑排序，同时判断：

1. 如果答案数组的长度小于 $n$，就有环（矛盾）。这是因为如果有点还孤立，它的入度也为 $0$，同样会被我们 `bfs` 到。只有在有环的情况下，才会有点没被 `bfs`。

2. 如果还有点孤立，顺序就还没有确定，拓扑排序的结果不能作为答案。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAX_N = 30;
bool g[MAX_N][MAX_N], vis[MAX_N];
int in[MAX_N], inn[MAX_N], n, m, cnt, tt;
vector<int> ans;
queue<int> s;
inline ll read() {...}
inline void write(ll x) {...}
bool topo() {
	vector<int> t;
	for(int i = 1; i <= n; i++) {
		inn[i] = in[i]; // 每一次排序都要删边，不能在原图上操作
		if(inn[i] == 0)	s.push(i);	
	}
	while(!s.empty()) {
		int u = s.front();
		s.pop();
		t.push_back(u);
		for(int v = 1; v <= n; v++) {
			if(!g[u][v])	continue;
			if(--inn[v] == 0)	s.push(v);
		}
	}
	if(t.size() < n)	return 0; // 有环的情况
	ans = t;
	return 1;
}

int main() {
	n = read(), m = read();
	string tmp;
	for(int i = 1; i <= m; i++) {
		cin >> tmp;
		int u = tmp[0] - 'A' + 1, v = tmp[2] - 'A' + 1;
		if(!vis[u])	tt++, vis[u] = 1;
		if(!vis[v])	tt++, vis[v] = 1; // tt 表示已经连入图的点数
		if(!g[u][v])	in[v]++;
		g[u][v] = 1;
		int res = topo();
		if(!res) {
			printf("Inconsistency found after %d relations.", i);
			return 0;
		}
		else if(res == 1 && !cnt && tt == n)	cnt = i;
		// 所有点都被连入图了且拓扑排序成功，那么记录答案位置
	}
	if(cnt) {
		printf("Sorted sequence determined after %d relations: ", cnt);
		for(int i = 0; i < ans.size(); i++)	putchar(ans[i] - 1 + 'A');	
		putchar('.');
	}
	else	printf("Sorted sequence cannot be determined.");
	return 0;
}

```

## 并查集

### 模板

[洛谷 P1111](https://www.luogu.com.cn/problem/P1111)

给出A地区的村庄数NN，和公路数MM，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）

#### 题解

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAX_N = 1005;
int f[MAX_N];
struct road {
	int u, v, t;
	bool operator < (const road &w) const {
		return t < w.t;
	}
};
vector <road> roads;

inline ll read() {...}
void write(ll x) {...}

int find(int k) {
	if(f[k] == k)	return k;
	return f[k] = find(f[k]);
}

int main() {
	int n = read(), m = read(), ans = -1;
	for(int i = 1; i <= n; i++)	f[i] = i;
	for(int i = 1; i <= m; i++) {
		road tmp;
		tmp.u = read(), tmp.v = read(), tmp.t = read();		
		roads.push_back(tmp);
	}
	sort(roads.begin(), roads.end());
	for(int i = 0; i < roads.size(); i++) {
		int fu = find(roads[i].u);
		int fv = find(roads[i].v);
		if(fu != fv)	f[fu] = fv, n--;
		if(n == 1) {
			ans = roads[i].t;
			break;
		}
	}
	write(ans);
	return 0;
}
```

### 利用并查集求最小环

[洛谷 P2661](https://www.luogu.com.cn/problem/P2661)

有 $n$ 个同学（编号为 $1$ 到 $n$ ）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学。

游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当**有人从别人口中得知自己的生日**时，游戏结束。请问该游戏一共可以进行几轮？

#### 题解

从 $u$ 到 $v$ 信息传递的过程可以视为从 $u$ 到 $v$ 连一条边。建完图后考虑图上最小环的长度即为答案。

可以使用并查集来查询是否形成环、计算环的长度。需要在原始的并查集基础上同时更新距离。也就是在树上往上走时使得 $dis_x$ 加上 $dis_{fa_x}$。注意这一步距离在路径压缩后再加，这样原来的 $dis_{fa_x}$ 会先被更新。环的长度即为 $dis_v+1$。

时间复杂度：$O(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAX_N = 2e5 + 10;
int f[MAX_N], dis[MAX_N];
inline ll read() {...}
inline void write(ll x) {...}
int fa(int x) {
	if(f[x] == x)	return x;
	int fo = f[x];
	f[x] = fa(f[x]);
	dis[x] += dis[fo];
	return f[x];
}
int main() {
	int n = read(), ans = (1 << 30);
	for(int i = 1; i <= n; i++)	f[i] = i;
	for(int u = 1; u <= n; u++) {
		int v = read();
		int fu = fa(u), fv = fa(v);
		if(fu == fv)	ans = min(ans, dis[v] + 1);
		else	f[fu] = fv, dis[u] = dis[v] + 1; 
	}
	write(ans);
	return 0;
}
```


## 单调栈模板

[洛谷 P5788](https://www.luogu.com.cn/problem/P5788)

给出项数为 $n$ 的整数数列 $a_{1 \dots n}$。

定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的**下标**，即 $f(i)=\min_{i<j\leq n, a_j > a_i} \{j\}$。若不存在，则 $f(i)=0$。

试求出 $f(1\dots n)$。

### 题解

题意即：给定序列，问序列中每个数后面第一个比它大的数的下标。

从后往前遍历，维护一个单调递增栈。

遍历到一个位置时，弹出栈顶**所有不大于它的数**。弹出后栈顶剩下的数即为答案。这是因为若一个数既小又靠后，它就没有什么意义，不会影响正确性。

注意栈里面存的是**下标**。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX_N = 3000006;
stack<int> s;
int a[MAX_N], ans[MAX_N];

inline int read() {...}
void write(int x) {...}

int main() {
	int n = read();
	for(int i = 1; i <= n; i++)	a[i] = read();
	for(int i = n; i >= 1; i--) {
		while(!s.empty() && a[s.top()] <= a[i])	s.pop();
		if(s.empty())	ans[i] = 0;
		else	ans[i] = s.top();
		s.push(i);
	}
	for(int i = 1; i <= n; i++)	write(ans[i]), putchar(' ');
	return 0;
}
```

### [例题] 积水面积

[洛谷 P1318](https://www.luogu.com.cn/problem/P1318)

一组正整数，分别表示由正方体叠起的柱子的高度。若某高度值为 $x$，表示由 $x$ 个正立方的方块叠起（如下图，$0 \le x \le 5000$）。找出所有可能积水的地方（图中蓝色部分），统计它们可能积水的面积总和（计算的是图中的横截面积。一个立方体的位置，为一个单位面积）。

如图：柱子高度变化为 `0 1 0 2 1 2 0 0 2 0`。

 ![](https://cdn.luogu.com.cn/upload/pic/117.png) 

图中蓝色部分为积水面积，共有 $6$ 个单位面积积水。

#### 题解

利用单调栈的思想：

正序遍历一遍，维护$lm_i = max\{a_1\dots a_i\}$；

逆序遍历一遍，维护$rm_i = max\{a_i\dots a_n\}$。

从而对于每一个位置$i$，它对答案的贡献为$min\{lm_i, rm_i \} - a_i$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAX_N = 50003;
int a[MAX_N], lmax[MAX_N], rmax[MAX_N];
inline ll read() {...}
void write(ll x) {...}

int main() {
	int n = read();
	ll ans = 0;
	for(int i = 1; i <= n; i++)	a[i] = read();
	for(int i = 1; i <= n; i++)	lmax[i] = max(lmax[i - 1], a[i]);
	for(int i = n; i >= 1; i--)	rmax[i] = max(rmax[i + 1], a[i]);
	for(int i = 1; i <= n; i++)	ans += min(lmax[i], rmax[i]) - a[i];
	write(ans);
	return 0;
}
```
也可以用双指针法，节省空间复杂度。大致思路是：

对于位置$s$，先处理$a_s$是一段积水中较小的边的情况。向后遍历，期间将 $tmp$ 加上 $a_s - a_i$，直到找到第一个比它高的值，将答案加上 $tmp$ ，从这个位置继续向后遍历。

完成遍历后，再反向遍历处理 $a_s$ 是一段积水中较大的边的情况即可。