---
layout: post
title: OI笔记 | 2022秋季杂类刷题题解
categories: OI
description: Note
keywords: NOIP, OI, Note, Binary 
---

# 贪心合集

## 线段覆盖

[洛谷 P1803](https://www.luogu.com.cn/problem/P1803)

给出 $n$ 条线段的左端点 $l$ 和右端点 $r$。问最多能够选出多少条互不重叠的线段（端点可重叠）。

### 题解

贪心的典例，即按照右端点从小到大排序，能选则选。

可以这样感性地考虑：右端点越小，对之后线段的妨碍越少。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

struct line {
	int l, r;
	bool operator < (const line &t) const {
		return r < t.r || (r == t.r && l > t.l);
	}
} a[1000005];

int main() {
	int n;
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> a[i].l >> a[i].r;
	sort(a + 1, a + n + 1);
	int ans = 0;
	int nr = a[1].l - 1;
	for(int i = 1; i <= n; i++) {
		if(a[i].l >= nr) {
			ans++;
			nr = a[i].r;
		}
	}
	cout << ans;
}
```

## 活动安排问题

有若干个活动，第i个开始时间和结束时间是 $[Si,fi)$。

同一个教室安排的活动之间不能交叠，求要安排所有活动，最少需要几个教室？

### 题解

即求线段重叠个数的最大值，可用类似于扫描线的思想。

遇到左端点答案$+1$，右端点答案$-1$，维护最大值即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct point {
	int pos;
	bool type; // 0 : l ; 1 : r
	bool operator < (const point &t) const {
		return pos < t.pos;
	}
};
vector <point> a;

inline int read() {
    ...
}

int main() {
	int n = read(), ans = 0, tmp = 0;
	for(int i = 1; i <= n; i++) {
		point l, r;
		l.pos = read(), r.pos = read();
		l.type = 0, r.type = 1;
		a.push_back(l);
		a.push_back(r);
	}
	sort(a.begin(), a.end());
	for(int i = 0; i < a.size(); i++) {
		if(a[i].type == 0)	tmp++;
		else	tmp--;
		ans = max(tmp, ans);
	}
	printf("%d", ans);
	return 0;
}
```

## 交换机器的最小代价

有N台机器重量各不相等，现在要求把这些机器按照重量排序，重量从左到右依次递增。移动机器只能做交换操作，但交换机器要花费一定的费用，费用的大小就是交换机器重量的和。例如：3 2 1，交换1 3后为递增排序，总的交换代价为4。给出N台机器的重量，求将所有机器变为有序的最小代价。（机器的重量均为正整数）

### 题解

考虑每个数最终要去到哪个位置。将这个数指向它要去的位置上的数，最终会形成一个环。答案就是 这若干个环内的最小代价 之和。

考虑每个环的最小代价如何取。

分两种情况：

1. 用这个环内最小的数$minn$来交换一遍。这样的做法$w=\sum\limits_{i=begin}^{end}(minn+a[i])=len\times minn +sum$。

2. 用整个数组中最小的数$M$来交换一遍。这样多了两次交换，但总代价可能变小。$w=(M+minn)\times 2 + (len\times M + sum)$。

取两种情况的最小值。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX_N = 50005;
typedef long long ll;
int a[MAX_N], b[MAX_N];

inline int read() {
    ...
}

int main() {
	ll n = read(), ans = 0;
	for(int i = 1; i <= n; i++) {
		a[i] = read();
		b[i] = a[i];	
	}
	sort(b + 1, b + n + 1);
	for(int i = 1; i <= n; i++) {
		if(a[i] == b[i] || a[i] == -1)	continue; // a[i] == -1 <-> a[i] is used
		int j = i;
		ll sum = 0, len = 0;
		while(a[j] != b[i]) { // 加和 a[i] 所在的环; a[j]为当前遍历到的环上的数
			len++;
			sum += a[j];
			int k = lower_bound(b + 1, b + n + 1, a[j]) - b; 
            // 在 b 中 O(logn)查找 a[j] 的位置 k，则 a[k] 为环中 a[j] 的下一个位置 
			a[j] = -1;
			j = k;			
		}
		a[j] = -1;
		ans += min(sum + len * b[i], sum + len * b[1] + (b[1] + b[i]) * 2);
	}
	cout << ans;
	return 0;
}
```

